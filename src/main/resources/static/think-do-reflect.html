<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Think-Do-Reflect å·¥ä½œæµ - OpenManus Java</title>
    
    <!-- Vue.js 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    
    <!-- Element Plus UI Library -->
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">
    <script src="https://unpkg.com/element-plus"></script>
    
    <!-- Element Plus Icons -->
    <script src="https://unpkg.com/@element-plus/icons-vue"></script>
    
    <!-- Markdown renderer -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- Highlight.js for code highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        .header h1 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 2.2em;
        }
        
        .header p {
            margin: 0;
            color: #6c757d;
            font-size: 1.1em;
        }
        
        .main-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 200px);
        }
        
        .workflow-status {
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #28a745;
        }
        
        .status-dot.loading {
            background: #ffc107;
            animation: pulse 1.5s infinite;
        }
        
        .status-dot.error {
            background: #dc3545;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .input-section {
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }
        
        .input-group .el-textarea {
            flex: 1;
        }
        
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .execution-options {
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            display: flex;
            align-items: center;
        }
        
        .results-section {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        
        .result-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #28a745;
        }
        
        .result-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .result-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            margin: 0;
        }
        
        .result-time {
            color: #6c757d;
            font-size: 0.9em;
        }
        
        .result-content {
            line-height: 1.6;
            color: #495057;
        }
        
        .workflow-phases {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .phase-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            min-width: 120px;
            transition: all 0.3s ease;
        }
        
        .phase-item.active {
            background: #e3f2fd;
            border: 2px solid #2196f3;
            transform: scale(1.05);
        }
        
        .phase-item.completed {
            background: #e8f5e8;
            border: 2px solid #4caf50;
        }
        
        .phase-icon {
            font-size: 2em;
            margin-bottom: 8px;
        }
        
        .phase-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 4px;
        }
        
        .phase-desc {
            font-size: 0.8em;
            color: #6c757d;
            text-align: center;
        }
        
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border: 1px solid #f5c6cb;
        }
        
        .loading-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: #667eea;
        }
        
        .loading-text {
            margin-left: 10px;
            font-size: 1.1em;
        }
        
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: #6c757d;
        }
        
        .empty-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .app-container {
                padding: 10px;
            }
            
            .workflow-phases {
                gap: 10px;
            }
            
            .phase-item {
                min-width: 100px;
                padding: 10px;
            }
            
            .input-group {
                flex-direction: column;
            }
            
            .main-panel {
                height: calc(100vh - 160px);
            }
        }
        
        /* Markdown æ ·å¼ */
        .result-content h1, .result-content h2, .result-content h3 {
            color: #2c3e50;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .result-content pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            padding: 12px;
            overflow: auto;
            margin: 10px 0;
        }
        
        .result-content code {
            font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
            font-size: 85%;
            background-color: #f6f8fa;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .result-content blockquote {
            border-left: 4px solid #dfe2e5;
            padding-left: 16px;
            margin: 16px 0;
            color: #6a737d;
        }
        
        .result-content ul, .result-content ol {
            padding-left: 20px;
        }
        
        .result-content li {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="app-container">
            <!-- å¤´éƒ¨ -->
            <div class="header">
                <h1>ğŸ§  Think-Do-Reflect å·¥ä½œæµ</h1>
                <p>åŸºäºå¾ªç¯åæ€çš„æ™ºèƒ½ä½“åä½œç³»ç»Ÿ - æƒ³ã€åšã€å›çš„å®Œæ•´æ¨ç†è¿‡ç¨‹</p>
            </div>
            
            <!-- ä¸»é¢æ¿ -->
            <div class="main-panel">
                <!-- å·¥ä½œæµçŠ¶æ€æ  -->
                <div class="workflow-status">
                    <div class="status-indicator">
                        <div :class="['status-dot', { 'loading': loading, 'error': error }]"></div>
                        <span>{{ statusText }}</span>
                    </div>
                    <div>
                        <el-button size="small" @click="checkHealth" :loading="healthChecking">
                            <el-icon><Refresh /></el-icon>
                            å¥åº·æ£€æŸ¥
                        </el-button>
                        <el-button size="small" @click="clearResults" :disabled="loading">
                            <el-icon><Delete /></el-icon>
                            æ¸…ç©ºç»“æœ
                        </el-button>
                    </div>
                </div>
                
                <div class="content-area">
                    <!-- è¾“å…¥åŒºåŸŸ -->
                    <div class="input-section">
                        <div class="input-group">
                            <el-input
                                v-model="userInput"
                                type="textarea"
                                :rows="3"
                                placeholder="è¯·è¾“å…¥æ‚¨çš„ä»»åŠ¡æˆ–é—®é¢˜ï¼Œç³»ç»Ÿå°†é€šè¿‡ Think-Do-Reflect å·¥ä½œæµè¿›è¡Œå¤„ç†..."
                                :disabled="loading"
                                @keyup.ctrl.enter="executeWorkflow">
                            </el-input>
                            <div class="button-group">
                                <el-button 
                                    type="primary" 
                                    size="large"
                                    @click="executeWorkflow"
                                    :loading="loading && !syncMode"
                                    :disabled="!userInput.trim() || loading">
                                    <el-icon><Play /></el-icon>
                                    {{ syncMode ? 'åŒæ­¥æ‰§è¡Œ' : 'å¼‚æ­¥æ‰§è¡Œ' }}
                                </el-button>
                                <el-button 
                                    type="success" 
                                    size="large"
                                    @click="executeWorkflowSync"
                                    :loading="loading && syncMode"
                                    :disabled="!userInput.trim() || loading">
                                    <el-icon><Tools /></el-icon>
                                    è°ƒè¯•æ¨¡å¼
                                </el-button>
                            </div>
                        </div>
                        <div class="execution-options">
                            <el-switch
                                v-model="syncMode"
                                :disabled="loading"
                                active-text="åŒæ­¥æ¨¡å¼"
                                inactive-text="å¼‚æ­¥æ¨¡å¼"
                                style="margin-right: 20px;">
                            </el-switch>
                            <span style="font-size: 0.9em; color: #6c757d;">
                                æç¤ºï¼šæŒ‰ Ctrl+Enter å¿«é€Ÿæ‰§è¡Œ | {{ syncMode ? 'åŒæ­¥æ¨¡å¼ä¾¿äºè°ƒè¯•ï¼Œä¼šé˜»å¡é¡µé¢' : 'å¼‚æ­¥æ¨¡å¼ä¸é˜»å¡é¡µé¢ï¼Œé€‚åˆç”Ÿäº§ç¯å¢ƒ' }}
                            </span>
                        </div>
                    </div>
                    
                    <!-- å·¥ä½œæµé˜¶æ®µæŒ‡ç¤ºå™¨ -->
                    <div v-if="loading || results.length > 0" class="workflow-phases">
                        <div :class="['phase-item', { 'active': currentPhase === 'thinking', 'completed': phaseCompleted.thinking }]">
                            <div class="phase-icon">ğŸ¤”</div>
                            <div class="phase-title">Think</div>
                            <div class="phase-desc">åˆ†ææ€è€ƒ</div>
                        </div>
                        <div :class="['phase-item', { 'active': currentPhase === 'doing', 'completed': phaseCompleted.doing }]">
                            <div class="phase-icon">âš¡</div>
                            <div class="phase-title">Do</div>
                            <div class="phase-desc">æ‰§è¡Œè¡ŒåŠ¨</div>
                        </div>
                        <div :class="['phase-item', { 'active': currentPhase === 'reflecting', 'completed': phaseCompleted.reflecting }]">
                            <div class="phase-icon">ğŸ”„</div>
                            <div class="phase-title">Reflect</div>
                            <div class="phase-desc">åæ€ä¼˜åŒ–</div>
                        </div>
                        <div :class="['phase-item', { 'active': currentPhase === 'completed', 'completed': phaseCompleted.completed }]">
                            <div class="phase-icon">âœ…</div>
                            <div class="phase-title">Complete</div>
                            <div class="phase-desc">ä»»åŠ¡å®Œæˆ</div>
                        </div>
                    </div>
                    
                    <!-- ç»“æœåŒºåŸŸ -->
                    <div class="results-section">
                        <!-- åŠ è½½çŠ¶æ€ -->
                        <div v-if="loading" class="loading-indicator">
                            <el-icon class="is-loading"><Loading /></el-icon>
                            <span class="loading-text">{{ loadingText }}</span>
                        </div>
                        
                        <!-- é”™è¯¯ä¿¡æ¯ -->
                        <div v-if="error" class="error-message">
                            <strong>æ‰§è¡Œå¤±è´¥ï¼š</strong>{{ error }}
                        </div>
                        
                        <!-- ç»“æœåˆ—è¡¨ -->
                        <div v-for="(result, index) in results" :key="index" class="result-card">
                            <div class="result-header">
                                <h3 class="result-title">
                                    <el-icon><DocumentCopy /></el-icon>
                                    ä»»åŠ¡ {{ index + 1 }}ï¼š{{ result.input }}
                                    <el-tag v-if="result.mode" :type="result.mode.includes('åŒæ­¥') ? 'success' : 'primary'" size="small" style="margin-left: 10px;">
                                        {{ result.mode }}
                                    </el-tag>
                                </h3>
                                <div class="result-actions">
                                    <el-button
                                        v-if="result.sessionId"
                                        type="primary"
                                        size="small"
                                        @click="openMonitor(result.sessionId)"
                                        style="margin-right: 10px;"
                                    >
                                        <el-icon><Monitor /></el-icon>
                                        æŸ¥çœ‹æ‰§è¡Œè¿‡ç¨‹
                                    </el-button>
                                    <span class="result-time">{{ formatTime(result.timestamp) }}</span>
                                </div>
                            </div>
                            <div class="result-content" v-html="renderMarkdown(result.result)"></div>
                        </div>
                        
                        <!-- ç©ºçŠ¶æ€ -->
                        <div v-if="!loading && results.length === 0 && !error" class="empty-state">
                            <div class="empty-icon">
                                <el-icon><Document /></el-icon>
                            </div>
                            <span>è¾“å…¥ä»»åŠ¡å¼€å§‹ä½¿ç”¨ Think-Do-Reflect å·¥ä½œæµ</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, reactive, computed, nextTick, onMounted } = Vue;
        const { ElMessage, ElMessageBox } = ElementPlus;
        
        createApp({
            setup() {
                const userInput = ref('');
                const loading = ref(false);
                const error = ref('');
                const results = ref([]);
                const healthChecking = ref(false);
                const currentPhase = ref('');
                const syncMode = ref(false);
                const phaseCompleted = reactive({
                    thinking: false,
                    doing: false,
                    reflecting: false,
                    completed: false
                });
                
                // è®¡ç®—çŠ¶æ€æ–‡æœ¬
                const statusText = computed(() => {
                    if (loading.value) {
                        return 'å·¥ä½œæµæ‰§è¡Œä¸­...';
                    } else if (error.value) {
                        return 'æ‰§è¡Œå¤±è´¥';
                    } else if (results.value.length > 0) {
                        return `å·²å®Œæˆ ${results.value.length} ä¸ªä»»åŠ¡`;
                    } else {
                        return 'å°±ç»ª';
                    }
                });
                
                // åŠ è½½æ–‡æœ¬
                const loadingText = computed(() => {
                    const texts = {
                        'thinking': 'æ­£åœ¨åˆ†æå’Œæ€è€ƒä»»åŠ¡...',
                        'doing': 'æ­£åœ¨æ‰§è¡Œå…·ä½“è¡ŒåŠ¨...',
                        'reflecting': 'æ­£åœ¨åæ€å’Œä¼˜åŒ–ç»“æœ...',
                        'completed': 'æ­£åœ¨æ•´ç†æœ€ç»ˆç»“æœ...'
                    };
                    return texts[currentPhase.value] || 'æ­£åœ¨å¤„ç†æ‚¨çš„è¯·æ±‚...';
                });
                
                // æ¨¡æ‹Ÿå·¥ä½œæµé˜¶æ®µè¿›å±•
                const simulatePhaseProgress = () => {
                    // é‡ç½®é˜¶æ®µçŠ¶æ€
                    Object.keys(phaseCompleted).forEach(key => {
                        phaseCompleted[key] = false;
                    });
                    
                    // æ¨¡æ‹Ÿé˜¶æ®µè¿›å±•
                    setTimeout(() => {
                        currentPhase.value = 'thinking';
                    }, 500);
                    
                    setTimeout(() => {
                        phaseCompleted.thinking = true;
                        currentPhase.value = 'doing';
                    }, 2000);
                    
                    setTimeout(() => {
                        phaseCompleted.doing = true;
                        currentPhase.value = 'reflecting';
                    }, 4000);
                    
                    setTimeout(() => {
                        phaseCompleted.reflecting = true;
                        currentPhase.value = 'completed';
                    }, 6000);
                };
                
                // æ‰§è¡Œå·¥ä½œæµï¼ˆå¼‚æ­¥ï¼‰
                const executeWorkflow = async () => {
                    if (!userInput.value.trim() || loading.value) return;
                    
                    const input = userInput.value.trim();
                    loading.value = true;
                    error.value = '';
                    currentPhase.value = '';
                    syncMode.value = false;
                    
                    // å¼€å§‹é˜¶æ®µè¿›å±•æ¨¡æ‹Ÿ
                    simulatePhaseProgress();
                    
                    try {
                        const response = await fetch('/api/think-do-reflect/execute', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                input: input
                            })
                        });
                        
                        const data = await response.json();
                        
                        if (!response.ok) {
                            throw new Error(data.error || `HTTP ${response.status}`);
                        }
                        
                        if (data.success) {
                            // æ·»åŠ æˆåŠŸç»“æœ
                            results.value.unshift({
                                input: input,
                                result: data.result,
                                timestamp: new Date(),
                                mode: 'å¼‚æ­¥æ‰§è¡Œ',
                                sessionId: data.sessionId
                            });

                            // å®Œæˆæ‰€æœ‰é˜¶æ®µ
                            phaseCompleted.completed = true;

                            // æ¸…ç©ºè¾“å…¥
                            userInput.value = '';

                            ElMessage.success({
                                message: 'å¼‚æ­¥å·¥ä½œæµæ‰§è¡ŒæˆåŠŸï¼',
                                duration: 3000,
                                showClose: true
                            });

                            // æ˜¾ç¤ºç›‘æ§é“¾æ¥
                            if (data.sessionId) {
                                ElMessage.info({
                                    message: `ä¼šè¯ID: ${data.sessionId}`,
                                    duration: 5000,
                                    showClose: true
                                });
                            }
                        } else {
                            throw new Error(data.error || 'æ‰§è¡Œå¤±è´¥');
                        }
                        
                    } catch (err) {
                        console.error('æ‰§è¡Œå·¥ä½œæµæ—¶å‡ºé”™:', err);
                        error.value = err.message || 'æ‰§è¡Œå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
                        ElMessage.error(error.value);
                    } finally {
                        loading.value = false;
                        currentPhase.value = '';
                    }
                };
                
                // æ‰§è¡Œå·¥ä½œæµï¼ˆåŒæ­¥ï¼‰
                const executeWorkflowSync = async () => {
                    if (!userInput.value.trim() || loading.value) return;
                    
                    const input = userInput.value.trim();
                    loading.value = true;
                    error.value = '';
                    currentPhase.value = '';
                    syncMode.value = true;
                    
                    // åŒæ­¥æ¨¡å¼ä¸éœ€è¦é˜¶æ®µè¿›å±•æ¨¡æ‹Ÿï¼Œç›´æ¥æ˜¾ç¤ºæ‰§è¡ŒçŠ¶æ€
                    currentPhase.value = 'thinking';
                    
                    try {
                        const startTime = Date.now();
                        const response = await fetch('/api/think-do-reflect/execute-sync', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                input: input
                            })
                        });
                        
                        const data = await response.json();
                        const executionTime = ((Date.now() - startTime) / 1000).toFixed(2);
                        
                        if (!response.ok) {
                            throw new Error(data.error || `HTTP ${response.status}`);
                        }
                        
                        if (data.success) {
                            // æ·»åŠ æˆåŠŸç»“æœ
                            results.value.unshift({
                                input: input,
                                result: data.result,
                                timestamp: new Date(),
                                mode: `åŒæ­¥æ‰§è¡Œ (${executionTime}s)`,
                                executionTime: executionTime
                            });
                            
                            // å®Œæˆæ‰€æœ‰é˜¶æ®µ
                            Object.keys(phaseCompleted).forEach(key => {
                                phaseCompleted[key] = true;
                            });
                            currentPhase.value = 'completed';
                            
                            // æ¸…ç©ºè¾“å…¥
                            userInput.value = '';
                            
                            ElMessage.success(`åŒæ­¥å·¥ä½œæµæ‰§è¡ŒæˆåŠŸï¼è€—æ—¶ ${executionTime} ç§’`);
                        } else {
                            throw new Error(data.error || 'æ‰§è¡Œå¤±è´¥');
                        }
                        
                    } catch (err) {
                        console.error('åŒæ­¥æ‰§è¡Œå·¥ä½œæµæ—¶å‡ºé”™:', err);
                        error.value = err.message || 'åŒæ­¥æ‰§è¡Œå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
                        ElMessage.error(error.value);
                    } finally {
                        loading.value = false;
                        currentPhase.value = '';
                    }
                };
                
                // å¥åº·æ£€æŸ¥
                const checkHealth = async () => {
                    healthChecking.value = true;
                    try {
                        const response = await fetch('/api/think-do-reflect/health');
                        const data = await response.json();
                        
                        if (response.ok && data.status === 'healthy') {
                            ElMessage.success('ç³»ç»Ÿè¿è¡Œæ­£å¸¸');
                        } else {
                            ElMessage.warning('ç³»ç»ŸçŠ¶æ€å¼‚å¸¸');
                        }
                    } catch (err) {
                        ElMessage.error('å¥åº·æ£€æŸ¥å¤±è´¥');
                    } finally {
                        healthChecking.value = false;
                    }
                };
                
                // æ¸…ç©ºç»“æœ
                const clearResults = () => {
                    if (results.value.length === 0) return;
                    
                    ElMessageBox.confirm(
                        'ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ‰§è¡Œç»“æœå—ï¼Ÿ',
                        'ç¡®è®¤æ¸…ç©º',
                        {
                            confirmButtonText: 'ç¡®å®š',
                            cancelButtonText: 'å–æ¶ˆ',
                            type: 'warning'
                        }
                    ).then(() => {
                        results.value = [];
                        error.value = '';
                        ElMessage.success('å·²æ¸…ç©ºæ‰€æœ‰ç»“æœ');
                    }).catch(() => {
                        // ç”¨æˆ·å–æ¶ˆ
                    });
                };
                
                // æ ¼å¼åŒ–æ—¶é—´
                const formatTime = (date) => {
                    return date.toLocaleString('zh-CN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                };
                
                // æ¸²æŸ“ Markdown
                const renderMarkdown = (text) => {
                    if (!text) return '';
                    try {
                        const rendered = marked.parse(text);
                        nextTick(() => {
                            document.querySelectorAll('pre code').forEach((block) => {
                                hljs.highlightElement(block);
                            });
                        });
                        return rendered;
                    } catch (e) {
                        return text;
                    }
                };
                
                // æ‰“å¼€ç›‘æ§ç•Œé¢
                const openMonitor = (sessionId) => {
                    const monitorUrl = `/agent-execution-monitor.html?sessionId=${sessionId}`;
                    window.open(monitorUrl, '_blank');
                };

                // ç»„ä»¶æŒ‚è½½æ—¶æ‰§è¡Œå¥åº·æ£€æŸ¥
                onMounted(() => {
                    checkHealth();
                });

                return {
                    userInput,
                    loading,
                    error,
                    results,
                    healthChecking,
                    currentPhase,
                    phaseCompleted,
                    syncMode,
                    statusText,
                    loadingText,
                    executeWorkflow,
                    executeWorkflowSync,
                    checkHealth,
                    clearResults,
                    formatTime,
                    renderMarkdown,
                    openMonitor
                };
            }
        }).use(ElementPlus).mount('#app');
        
        // æ³¨å†Œ Element Plus å›¾æ ‡
        const app = createApp({});
        for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
            app.component(key, component);
        }
    </script>
</body>
</html>
