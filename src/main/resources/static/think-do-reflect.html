<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Think-Do-Reflect Â∑•‰ΩúÊµÅ - OpenManus Java</title>
    
    <!-- Vue.js 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    
    <!-- Element Plus UI Library -->
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">
    <script src="https://unpkg.com/element-plus"></script>
    
    <!-- Element Plus Icons -->
    <script src="https://unpkg.com/@element-plus/icons-vue"></script>
    
    <!-- Markdown renderer -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- Highlight.js for code highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        .header h1 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 2.2em;
        }
        
        .header p {
            margin: 0;
            color: #6c757d;
            font-size: 1.1em;
        }
        
        .main-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 200px);
        }
        
        .workflow-status {
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #28a745;
        }
        
        .status-dot.loading {
            background: #ffc107;
            animation: pulse 1.5s infinite;
        }
        
        .status-dot.error {
            background: #dc3545;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .input-section {
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }
        
        .input-group .el-textarea {
            flex: 1;
        }
        
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .execution-options {
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            display: flex;
            align-items: center;
        }
        
        .results-section {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        
        .result-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #28a745;
        }
        
        .result-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .result-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            margin: 0;
        }
        
        .result-time {
            color: #6c757d;
            font-size: 0.9em;
        }
        
        .result-content {
            line-height: 1.6;
            color: #495057;
        }
        
        .workflow-phases {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .phase-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            min-width: 120px;
            transition: all 0.3s ease;
        }
        
        .phase-item.active {
            background: #e3f2fd;
            border: 2px solid #2196f3;
            transform: scale(1.05);
        }
        
        .phase-item.completed {
            background: #e8f5e8;
            border: 2px solid #4caf50;
        }
        
        .phase-icon {
            font-size: 2em;
            margin-bottom: 8px;
        }
        
        .phase-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 4px;
        }
        
        .phase-desc {
            font-size: 0.8em;
            color: #6c757d;
            text-align: center;
        }
        
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border: 1px solid #f5c6cb;
        }
        
        .loading-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: #667eea;
        }
        
        .loading-text {
            margin-left: 10px;
            font-size: 1.1em;
        }
        
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: #6c757d;
        }
        
        .empty-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }
        
        /* ÂìçÂ∫îÂºèËÆæËÆ° */
        @media (max-width: 768px) {
            .app-container {
                padding: 10px;
            }
            
            .workflow-phases {
                gap: 10px;
            }
            
            .phase-item {
                min-width: 100px;
                padding: 10px;
            }
            
            .input-group {
                flex-direction: column;
            }
            
            .main-panel {
                height: calc(100vh - 160px);
            }
        }
        
        /* Markdown Ê†∑Âºè */
        .result-content h1, .result-content h2, .result-content h3 {
            color: #2c3e50;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .result-content pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            padding: 12px;
            overflow: auto;
            margin: 10px 0;
        }
        
        .result-content code {
            font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
            font-size: 85%;
            background-color: #f6f8fa;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .result-content blockquote {
            border-left: 4px solid #dfe2e5;
            padding-left: 16px;
            margin: 16px 0;
            color: #6a737d;
        }
        
        .result-content ul, .result-content ol {
            padding-left: 20px;
        }
        
        .result-content li {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="app-container">
            <!-- Â§¥ÈÉ® -->
            <div class="header">
                <h1>üß† Think-Do-Reflect Â∑•‰ΩúÊµÅ</h1>
                <p>Âü∫‰∫éÂæ™ÁéØÂèçÊÄùÁöÑÊô∫ËÉΩ‰ΩìÂçè‰ΩúÁ≥ªÁªü - ÊÉ≥„ÄÅÂÅö„ÄÅÂõûÁöÑÂÆåÊï¥Êé®ÁêÜËøáÁ®ã</p>
            </div>
            
            <!-- ‰∏ªÈù¢Êùø -->
            <div class="main-panel">
                <!-- Â∑•‰ΩúÊµÅÁä∂ÊÄÅÊ†è -->
                <div class="workflow-status">
                    <div class="status-indicator">
                        <div :class="['status-dot', { 'loading': loading, 'error': error }]"></div>
                        <span>{{ statusText }}</span>
                    </div>
                    <div>
                        <el-button size="small" @click="checkHealth" :loading="healthChecking">
                            <el-icon><Refresh /></el-icon>
                            ÂÅ•Â∫∑Ê£ÄÊü•
                        </el-button>
                        <el-button size="small" @click="clearResults" :disabled="loading">
                            <el-icon><Delete /></el-icon>
                            Ê∏ÖÁ©∫ÁªìÊûú
                        </el-button>
                    </div>
                </div>
                
                <div class="content-area">
                    <!-- ËæìÂÖ•Âå∫Âüü -->
                    <div class="input-section">
                        <div class="input-group">
                            <el-input
                                v-model="userInput"
                                type="textarea"
                                :rows="3"
                                placeholder="ËØ∑ËæìÂÖ•ÊÇ®ÁöÑ‰ªªÂä°ÊàñÈóÆÈ¢òÔºåÁ≥ªÁªüÂ∞ÜÈÄöËøá Think-Do-Reflect Â∑•‰ΩúÊµÅËøõË°åÂ§ÑÁêÜ..."
                                :disabled="loading"
                                @keyup.ctrl.enter="executeWorkflow">
                            </el-input>
                            <div class="button-group">
                                <el-button 
                                    type="primary" 
                                    size="large"
                                    @click="executeWorkflow"
                                    :loading="loading && !syncMode"
                                    :disabled="!userInput.trim() || loading">
                                    <el-icon><Play /></el-icon>
                                    {{ syncMode ? 'ÂêåÊ≠•ÊâßË°å' : 'ÂºÇÊ≠•ÊâßË°å' }}
                                </el-button>
                                <el-button 
                                    type="success" 
                                    size="large"
                                    @click="executeWorkflowSync"
                                    :loading="loading && syncMode"
                                    :disabled="!userInput.trim() || loading">
                                    <el-icon><Tools /></el-icon>
                                    Ë∞ÉËØïÊ®°Âºè
                                </el-button>
                            </div>
                        </div>
                        <div class="execution-options">
                            <el-switch
                                v-model="syncMode"
                                :disabled="loading"
                                active-text="ÂêåÊ≠•Ê®°Âºè"
                                inactive-text="ÂºÇÊ≠•Ê®°Âºè"
                                style="margin-right: 20px;">
                            </el-switch>
                            <span style="font-size: 0.9em; color: #6c757d;">
                                ÊèêÁ§∫ÔºöÊåâ Ctrl+Enter Âø´ÈÄüÊâßË°å | {{ syncMode ? 'ÂêåÊ≠•Ê®°Âºè‰æø‰∫éË∞ÉËØïÔºå‰ºöÈòªÂ°ûÈ°µÈù¢' : 'ÂºÇÊ≠•Ê®°Âºè‰∏çÈòªÂ°ûÈ°µÈù¢ÔºåÈÄÇÂêàÁîü‰∫ßÁéØÂ¢É' }}
                            </span>
                        </div>
                    </div>
                    
                    <!-- Â∑•‰ΩúÊµÅÈò∂ÊÆµÊåáÁ§∫Âô® -->
                    <div v-if="loading || results.length > 0" class="workflow-phases">
                        <div :class="['phase-item', { 'active': currentPhase === 'thinking', 'completed': phaseCompleted.thinking }]">
                            <div class="phase-icon">ü§î</div>
                            <div class="phase-title">Think</div>
                            <div class="phase-desc">ÂàÜÊûêÊÄùËÄÉ</div>
                        </div>
                        <div :class="['phase-item', { 'active': currentPhase === 'doing', 'completed': phaseCompleted.doing }]">
                            <div class="phase-icon">‚ö°</div>
                            <div class="phase-title">Do</div>
                            <div class="phase-desc">ÊâßË°åË°åÂä®</div>
                        </div>
                        <div :class="['phase-item', { 'active': currentPhase === 'reflecting', 'completed': phaseCompleted.reflecting }]">
                            <div class="phase-icon">üîÑ</div>
                            <div class="phase-title">Reflect</div>
                            <div class="phase-desc">ÂèçÊÄù‰ºòÂåñ</div>
                        </div>
                        <div :class="['phase-item', { 'active': currentPhase === 'completed', 'completed': phaseCompleted.completed }]">
                            <div class="phase-icon">‚úÖ</div>
                            <div class="phase-title">Complete</div>
                            <div class="phase-desc">‰ªªÂä°ÂÆåÊàê</div>
                        </div>
                    </div>
                    
                    <!-- ÁªìÊûúÂå∫Âüü -->
                    <div class="results-section">
                        <!-- Âä†ËΩΩÁä∂ÊÄÅ -->
                        <div v-if="loading" class="loading-indicator">
                            <el-icon class="is-loading"><Loading /></el-icon>
                            <span class="loading-text">{{ loadingText }}</span>
                        </div>
                        
                        <!-- ÈîôËØØ‰ø°ÊÅØ -->
                        <div v-if="error" class="error-message">
                            <strong>ÊâßË°åÂ§±Ë¥•Ôºö</strong>{{ error }}
                        </div>
                        
                        <!-- ÁªìÊûúÂàóË°® -->
                        <div v-for="(result, index) in results" :key="index" class="result-card">
                            <div class="result-header">
                                <h3 class="result-title">
                                    <el-icon><DocumentCopy /></el-icon>
                                    ‰ªªÂä° {{ index + 1 }}Ôºö{{ result.input }}
                                    <el-tag v-if="result.mode" :type="result.mode.includes('ÂêåÊ≠•') ? 'success' : 'primary'" size="small" style="margin-left: 10px;">
                                        {{ result.mode }}
                                    </el-tag>
                                </h3>
                                <div class="result-actions">
                                    <el-button
                                        v-if="result.sessionId"
                                        type="primary"
                                        size="small"
                                        @click="openMonitor(result.sessionId)"
                                        style="margin-right: 10px;"
                                    >
                                        <el-icon><Monitor /></el-icon>
                                        Êü•ÁúãÊâßË°åËøáÁ®ã
                                    </el-button>
                                    <span class="result-time">{{ formatTime(result.timestamp) }}</span>
                                </div>
                            </div>
                            <div class="result-content" v-html="renderMarkdown(result.result)"></div>
                        </div>
                        
                        <!-- Á©∫Áä∂ÊÄÅ -->
                        <div v-if="!loading && results.length === 0 && !error" class="empty-state">
                            <div class="empty-icon">
                                <el-icon><Document /></el-icon>
                            </div>
                            <span>ËæìÂÖ•‰ªªÂä°ÂºÄÂßã‰ΩøÁî® Think-Do-Reflect Â∑•‰ΩúÊµÅ</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, reactive, computed, nextTick, onMounted } = Vue;
        const { ElMessage, ElMessageBox } = ElementPlus;
        
        createApp({
            setup() {
                const userInput = ref('');
                const loading = ref(false);
                const error = ref('');
                const results = ref([]);
                const healthChecking = ref(false);
                const currentPhase = ref('');
                const syncMode = ref(false);
                const phaseCompleted = reactive({
                    thinking: false,
                    doing: false,
                    reflecting: false,
                    completed: false
                });
                
                // ËÆ°ÁÆóÁä∂ÊÄÅÊñáÊú¨
                const statusText = computed(() => {
                    if (loading.value) {
                        return 'Â∑•‰ΩúÊµÅÊâßË°å‰∏≠...';
                    } else if (error.value) {
                        return 'ÊâßË°åÂ§±Ë¥•';
                    } else if (results.value.length > 0) {
                        return `Â∑≤ÂÆåÊàê ${results.value.length} ‰∏™‰ªªÂä°`;
                    } else {
                        return 'Â∞±Áª™';
                    }
                });
                
                // Âä†ËΩΩÊñáÊú¨
                const loadingText = computed(() => {
                    const texts = {
                        'thinking': 'Ê≠£Âú®ÂàÜÊûêÂíåÊÄùËÄÉ‰ªªÂä°...',
                        'doing': 'Ê≠£Âú®ÊâßË°åÂÖ∑‰ΩìË°åÂä®...',
                        'reflecting': 'Ê≠£Âú®ÂèçÊÄùÂíå‰ºòÂåñÁªìÊûú...',
                        'completed': 'Ê≠£Âú®Êï¥ÁêÜÊúÄÁªàÁªìÊûú...'
                    };
                    return texts[currentPhase.value] || 'Ê≠£Âú®Â§ÑÁêÜÊÇ®ÁöÑËØ∑Ê±Ç...';
                });
                
                // Ê®°ÊãüÂ∑•‰ΩúÊµÅÈò∂ÊÆµËøõÂ±ï
                const simulatePhaseProgress = () => {
                    // ÈáçÁΩÆÈò∂ÊÆµÁä∂ÊÄÅ
                    Object.keys(phaseCompleted).forEach(key => {
                        phaseCompleted[key] = false;
                    });
                    
                    // Ê®°ÊãüÈò∂ÊÆµËøõÂ±ï
                    setTimeout(() => {
                        currentPhase.value = 'thinking';
                    }, 500);
                    
                    setTimeout(() => {
                        phaseCompleted.thinking = true;
                        currentPhase.value = 'doing';
                    }, 2000);
                    
                    setTimeout(() => {
                        phaseCompleted.doing = true;
                        currentPhase.value = 'reflecting';
                    }, 4000);
                    
                    setTimeout(() => {
                        phaseCompleted.reflecting = true;
                        currentPhase.value = 'completed';
                    }, 6000);
                };
                
                // ÊâßË°åÂ∑•‰ΩúÊµÅÔºàÂºÇÊ≠•Ôºâ
                const executeWorkflow = async () => {
                    if (!userInput.value.trim() || loading.value) return;
                    
                    const input = userInput.value.trim();
                    loading.value = true;
                    error.value = '';
                    currentPhase.value = '';
                    syncMode.value = false;
                    
                    // ÂºÄÂßãÈò∂ÊÆµËøõÂ±ïÊ®°Êãü
                    simulatePhaseProgress();
                    
                    try {
                        const response = await fetch('/api/think-do-reflect/execute', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                input: input
                            })
                        });
                        
                        const data = await response.json();
                        
                        if (!response.ok) {
                            throw new Error(data.error || `HTTP ${response.status}`);
                        }
                        
                        if (data.success) {
                            // Ê∑ªÂä†ÊàêÂäüÁªìÊûú
                            results.value.unshift({
                                input: input,
                                result: data.result,
                                timestamp: new Date(),
                                mode: 'ÂºÇÊ≠•ÊâßË°å',
                                sessionId: data.sessionId
                            });

                            // ÂÆåÊàêÊâÄÊúâÈò∂ÊÆµ
                            phaseCompleted.completed = true;

                            // Ê∏ÖÁ©∫ËæìÂÖ•
                            userInput.value = '';

                            ElMessage.success({
                                message: 'ÂºÇÊ≠•Â∑•‰ΩúÊµÅÊâßË°åÊàêÂäüÔºÅ',
                                duration: 3000,
                                showClose: true
                            });

                            // ÊòæÁ§∫ÁõëÊéßÈìæÊé•
                            if (data.sessionId) {
                                ElMessage.info({
                                    message: `‰ºöËØùID: ${data.sessionId}`,
                                    duration: 5000,
                                    showClose: true
                                });
                            }
                        } else {
                            throw new Error(data.error || 'ÊâßË°åÂ§±Ë¥•');
                        }
                        
                    } catch (err) {
                        console.error('ÊâßË°åÂ∑•‰ΩúÊµÅÊó∂Âá∫Èîô:', err);
                        error.value = err.message || 'ÊâßË°åÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï';
                        ElMessage.error(error.value);
                    } finally {
                        loading.value = false;
                        currentPhase.value = '';
                    }
                };
                
                // ÊâßË°åÂ∑•‰ΩúÊµÅÔºàÂêåÊ≠•Ôºâ
                const executeWorkflowSync = async () => {
                    if (!userInput.value.trim() || loading.value) return;
                    
                    const input = userInput.value.trim();
                    loading.value = true;
                    error.value = '';
                    currentPhase.value = '';
                    syncMode.value = true;
                    
                    // ÂêåÊ≠•Ê®°Âºè‰∏çÈúÄË¶ÅÈò∂ÊÆµËøõÂ±ïÊ®°ÊãüÔºåÁõ¥Êé•ÊòæÁ§∫ÊâßË°åÁä∂ÊÄÅ
                    currentPhase.value = 'thinking';
                    
                    try {
                        const startTime = Date.now();
                        const response = await fetch('/api/think-do-reflect/execute-sync', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                input: input
                            })
                        });
                        
                        const data = await response.json();
                        const executionTime = ((Date.now() - startTime) / 1000).toFixed(2);
                        
                        if (!response.ok) {
                            throw new Error(data.error || `HTTP ${response.status}`);
                        }
                        
                        if (data.success) {
                            // Ê∑ªÂä†ÊàêÂäüÁªìÊûú
                            results.value.unshift({
                                input: input,
                                result: data.result,
                                timestamp: new Date(),
                                mode: `ÂêåÊ≠•ÊâßË°å (${executionTime}s)`,
                                executionTime: executionTime
                            });
                            
                            // ÂÆåÊàêÊâÄÊúâÈò∂ÊÆµ
                            Object.keys(phaseCompleted).forEach(key => {
                                phaseCompleted[key] = true;
                            });
                            currentPhase.value = 'completed';
                            
                            // Ê∏ÖÁ©∫ËæìÂÖ•
                            userInput.value = '';
                            
                            ElMessage.success(`ÂêåÊ≠•Â∑•‰ΩúÊµÅÊâßË°åÊàêÂäüÔºÅËÄóÊó∂ ${executionTime} Áßí`);
                        } else {
                            throw new Error(data.error || 'ÊâßË°åÂ§±Ë¥•');
                        }
                        
                    } catch (err) {
                        console.error('ÂêåÊ≠•ÊâßË°åÂ∑•‰ΩúÊµÅÊó∂Âá∫Èîô:', err);
                        error.value = err.message || 'ÂêåÊ≠•ÊâßË°åÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï';
                        ElMessage.error(error.value);
                    } finally {
                        loading.value = false;
                        currentPhase.value = '';
                    }
                };
                
                // ÂÅ•Â∫∑Ê£ÄÊü•
                const checkHealth = async () => {
                    healthChecking.value = true;
                    try {
                        const response = await fetch('/api/think-do-reflect/health');
                        const data = await response.json();
                        
                        if (response.ok && data.status === 'healthy') {
                            ElMessage.success('Á≥ªÁªüËøêË°åÊ≠£Â∏∏');
                        } else {
                            ElMessage.warning('Á≥ªÁªüÁä∂ÊÄÅÂºÇÂ∏∏');
                        }
                    } catch (err) {
                        ElMessage.error('ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•');
                    } finally {
                        healthChecking.value = false;
                    }
                };
                
                // Ê∏ÖÁ©∫ÁªìÊûú
                const clearResults = () => {
                    if (results.value.length === 0) return;
                    
                    ElMessageBox.confirm(
                        'Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÊâßË°åÁªìÊûúÂêóÔºü',
                        'Á°ÆËÆ§Ê∏ÖÁ©∫',
                        {
                            confirmButtonText: 'Á°ÆÂÆö',
                            cancelButtonText: 'ÂèñÊ∂à',
                            type: 'warning'
                        }
                    ).then(() => {
                        results.value = [];
                        error.value = '';
                        ElMessage.success('Â∑≤Ê∏ÖÁ©∫ÊâÄÊúâÁªìÊûú');
                    }).catch(() => {
                        // Áî®Êà∑ÂèñÊ∂à
                    });
                };
                
                // Ê†ºÂºèÂåñÊó∂Èó¥
                const formatTime = (date) => {
                    return date.toLocaleString('zh-CN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                };
                
                // Ê∏≤Êüì Markdown
                const renderMarkdown = (text) => {
                    if (!text) return '';
                    try {
                        const rendered = marked.parse(text);
                        nextTick(() => {
                            document.querySelectorAll('pre code').forEach((block) => {
                                hljs.highlightElement(block);
                            });
                        });
                        return rendered;
                    } catch (e) {
                        return text;
                    }
                };
                
                // ÊâìÂºÄÁõëÊéßÁïåÈù¢
                const openMonitor = (sessionId) => {
                    const monitorUrl = `/agent-execution-monitor.html?sessionId=${sessionId}`;
                    window.open(monitorUrl, '_blank');
                };

                // ÁªÑ‰ª∂ÊåÇËΩΩÊó∂ÊâßË°åÂÅ•Â∫∑Ê£ÄÊü•
                onMounted(() => {
                    checkHealth();
                });

                return {
                    userInput,
                    loading,
                    error,
                    results,
                    healthChecking,
                    currentPhase,
                    phaseCompleted,
                    syncMode,
                    statusText,
                    loadingText,
                    executeWorkflow,
                    executeWorkflowSync,
                    checkHealth,
                    clearResults,
                    formatTime,
                    renderMarkdown,
                    openMonitor
                };
            }
        }).use(ElementPlus).mount('#app');
        
        // Ê≥®ÂÜå Element Plus ÂõæÊ†á
        const app = createApp({});
        for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
            app.component(key, component);
        }
    </script>
</body>
</html>
